"""This file implements a series of wrapper classes for the syntaxof the Graphviz language.The dependency tree of the classes is:        GraphvizStatement     |     |-> SimpleStatement     |    |     |    |-> NodeStatement *     |    |     |    |-> EdgeStatement *     |         |-> ComplexStatement          |          |-> GraphStatement          |    |          |    |-> Graph *          |    |          |    |-> Digraph *          |          |-> Subgraph *               |               |-> Cluster *               The classes marked with * are those meant to be directly employed by the user.In this file, the templates of the available statements are described using the following syntax:        template_id : template_description    Inside the template description, the following rules apply:    - Other template ids are always written as plain words.    - User imput is identified by enclosing stars (*).        E.g.: the token *id* stands for any user-defined id    - Literal values are enclosed in single quotes (').        E.g.: the token '=' is to be replaced exactky by the symbol =    - Alternatives are sparated by vertical bats (|).        E.g.: the token token_1 | token_2 can be replaced wither by token_1 or by token_2    - Optional values are enclosed in square brackets ([ ]).        E.g.: the token token_1 [token_2] is to be replaced either by token_1 or by token_1 token_2"""class GraphvizStatement:    """    Baseline class    It simply stores the parameters and exposes the assemble method    """        def __init__(self, keyword, **kwargs):        """        Parameters:            keyword: the main command that defines the statement (e.g., node, edge, graph, ...)            **kwargs: a series of key-value pairs that corespond to the attributes allowed by Graphviz for the                specified statement (optional)        """                self.keyword = keyword        self.attributes = kwargs         def assemble(self):        """        Placeholder. Exposure of the assemble method.                Assembles the statement by combining together the provided input parameters        """                passclass SimpleStatement(GraphvizStatement):    """    This class wraps the concept of a Graphviz statement that can be expressed in one line    using the template        SimpleStatement         :   keyword [ attribute_list ] ';'                keyword                 :   attribute_statement | declaration_statement        attribute_statement     :   'node' | 'edge'        declaration_statement   :   node_declaration | edge_declaration        node_declaration        :   *node_id*        edge_declaration        :   *node1_id* edge_type *node2_id*        edge_type               :   '--' | '->'        attribute_list          :   '[' list ']'        list                    :   *key* '=' '"'*value*'"' [',' list]    """        def __init__(self, keyword, is_attribute, **kwargs):        """        Initialises the simple statement.                Parameters:            keyword: the keyword (see class description), string            is_attribute: whether this is an attribute statement (see class description) (boolean)            **kwargs: a series of named arguments defining the attribute list for nodes (string) (optional)                    """                super().__init__(keyword, **kwargs)                self.is_attribute = is_attribute        def assemble(self):        """        Assembles the statement                Returns:            a string that follows the SimpleStatement pattern (see class description)        """                statement = f"{self.keyword}"                if len(self.attributes) > 0:            statement += " ["            statement += ", ".join([f"{key} = \"{value}\"" for key, value in self.attributes.items()])            statement += "]"                statement += ";"                return statementclass NodeStatement(SimpleStatement):    """    A class that wraps the concept of a SimpleStatement related to nodes:                NodeStatement   :   keyword [ attribute_list ] ';'                keyword         :   'node' | *node_id*        attribute_list  :   '[' list ']'        list            :   *key* '=' '"'*value*'"' [',' list]    """        def __init__(self, node_id = None, **kwargs):        """        Parameters:            node_id: the id of the node, if None the keyword defaults to 'node' and                 the statement defaults to an attribute statement (see SimpleStatement                 class description) (string). Default: None            **kwargs: a series of named arguments defining the attribute list for nodes (string) (optional)        """                super().__init__(            node_id if node_id is not None else "node",            node_id is None,            **kwargs        )class EdgeStatement(SimpleStatement):    """    A class that wraps the concept of a SimpleStatement related to edges:                NodeStatement       :   keyword [ attribute_list ] ';'                keyword             :   'edge' | edge_declaration        edge_declaration    :   *node1_id* edge_type *node2_id*        edge_type           :   '--' | '->'        attribute_list      :   '[' list ']'        list                :   *key* '=' '"'*value*'"' [',' list]            NOTE: the edge type is automatically determined by the GraphStatement this statement is added to,    so until this statement is assembled within a graph, the edge type will be replaced by the placeholder %s    """        def __init__(self, edge = None, **kwargs):        """        Parameters:            edge: a list (or tuple) containing node1_id and node2_id, if None the keyword defaults                 to 'edge' and the statement defaults to an attribute statement (see SimpleStatement                 class description). Default: None            **kwargs: a series of named arguments defining the attribute list for nodes (string) (optional)        """                super().__init__(            f"{edge[0]} %s {edge[1]}" if edge is not None else "edge",            edge is None,            **kwargs        )        class ComplexStatement(GraphvizStatement):    """    This class wraps the concept of a Graphviz statement that may require multiple lines to be expressed,    using the template        ComplexStatement    :   keyword [*ID*] '{' statement_list '}'                keyword             :   'graph' | 'digraph' | 'subgraph'        statement_list      :   statement [statement_list]        statement           :   attribute | SimpleStatement | ComplexStatement        attribute           :   *key* '=' '"'*value*'"' ';'    """        def __init__(self, keyword, *args, **kwargs):        """        Initialises the complex statement                Parameters:            - keyword: the keyword            *args: a series of SimpleStatement, Subgraph or Cluster instances to be embedded into                the complex statement (optional)            **kwargs: a series of named arguments defining the attribute list                 for graphs, digraphs, subgraphs or clusters (string). If you wish                to provide an id for the complex statement you have to pass it as a                parameter named 'name' (to avoid conflict with the 'id' attribute                allowed by Graphviz) (optional)        """                super().__init__(keyword, **kwargs)                self.args = args                # The id is not an attribute in the sense of Graphviz syntax, so it        #   has to be removed        self.name = self.attributes.pop("name", None)                # Default value of safety flag, classes that do not allow        #   to be embedded have to change this        self.can_be_child = True                # Default value of edge type, classes that prescribe a        #   specific type have to change this        self.edge_type = "%s"                # Helper variables that will store and classify        #   the statements other than the attributes        self.simple_statements = {                "attribute": {"nodes": [], "edges": []},                "nonattribute": {"nodes": [], "edges": []}            }        self.complex_statements = []                # Add the statements that are not attributes        self.add_statements(*args)        def add_statements(self, *args):        """        Add new SimpleStatement, Subgraph or Cluster instances to be embedded into the complex statement                Parameters:            *args: a series of SimpleStatement, Subgraph or Cluster instances to be embedded into                the complex statement (optional)        """                # Helper variables: allow easy access to the key that correctly stores        #   the statements in self.simple_statements, depending on whether the simple        #   statement is an attribute statement and it refers to nodes or edges        is_attribute = {True: "attribute", False: "nonattribute"}        is_node = {True: "nodes", False: "edges"}                for statement in args:            if isinstance(statement, SimpleStatement):                self.simple_statements[                        is_attribute[statement.is_attribute]                    ][                        is_node[isinstance(statement, NodeStatement)]                    ]+= [statement]            else:                self.complex_statements += [statement]                # Sanity check: verify that all the provided statements are of the correct type        for stmnt in self.complex_statements:            if not isinstance(stmnt, ComplexStatement):                raise Exception(f"Error while adding statements to complex statement: trying to add something that is not a SimpleStatement or a ComplexStatement! Trying to add: {type(stmnt)}")                    if not all( stmnt.can_be_child for stmnt in self.complex_statements ):            raise Exception("Error while adding statements to complex statement: trying to add graph/digraph as a child!")                    def assemble(self):        """        Assembles the complex statement                Returns:            A dictionary with two entries:                - 'statement': A statement following the ComplexStatement template (see class description)                - 'lines': the statement broke into lines        """                # Helper variables: the complex statement is written in the order        #        #   1. attributes        #   2. node attribute statements        #   3. edge attribute statemens        #   4. complex statements        #   5. node statements        #   6. edge statements        #        #   and in between each group of statements there should be an empty line, hence it is        #   necessary to know whether or not each group is empty or has any statements        #   To ensure a nice formatting, after attempting to write each group, it is necessary        #   to check if 1. something has been written AND 2. something will be written after. If so        #   an empty line has to be added. The following variables perform all of these checks beforehand        have_to_write_attr = len(self.attributes.items()) > 0        have_to_write_simple_attr_statements = {                "edges": len(self.simple_statements["attribute"]["edges"]) > 0,                "nodes": len(self.simple_statements["attribute"]["nodes"]) > 0            }        have_to_write_complex_statements = len(self.complex_statements) > 0        have_to_write_simple_nonattr_statements = {                "edges": len(self.simple_statements["nonattribute"]["edges"]) > 0,                "nodes": len(self.simple_statements["nonattribute"]["nodes"]) > 0            }                # Container list for all the lines of the statement        statements = []                # Opening line of the statement: keyword [*id*] '{'        statements += [                self.keyword \                + (f" {self.name}" if self.name is not None else "") \                + " {"            ]                    # Add attributes        for key, value in self.attributes.items():            statements += [f'\t{key} = \"{value}\";']                    if have_to_write_attr and have_to_write_simple_attr_statements:            statements += [""] # newline                    # Add simple attribute statements (nodes)        for statement in self.simple_statements["attribute"]["nodes"]:            statements += ["\t" + statement.assemble()]                if have_to_write_simple_attr_statements["nodes"] and (                    have_to_write_simple_attr_statements["edges"] or                    have_to_write_complex_statements or                    have_to_write_simple_nonattr_statements["nodes"] or                    have_to_write_simple_nonattr_statements["edges"]                ):            statements += [""] # newline                # Add simple attribute statements (edges)        for statement in self.simple_statements["attribute"]["edges"]:            statements += ["\t" + statement.assemble()]                    if have_to_write_simple_attr_statements["edges"] and (                    have_to_write_complex_statements or                    have_to_write_simple_nonattr_statements["nodes"] or                    have_to_write_simple_nonattr_statements["edges"]                ):            statements += [""] # newline                    # Add complex statements        for s_idx in range(len(self.complex_statements)):            statement = self.complex_statements[s_idx]                        # Inherit edge type from enclosing complex statement            #   Only top objects like graphs and digraphs can            #   define an edge type            old_edge_type = statement.edge_type            statement.edge_type = self.edge_type                        # Retrieve child statments and add them to the complex statement lines            statements_of_child = statement.assemble()["lines"]            statements += ["\t" + soc for soc in statements_of_child]                        # Restore original edge type (%s)            statement.edge_type = old_edge_type                        if s_idx < len(self.complex_statements) - 1:                statements += [""] # newline                if have_to_write_complex_statements and (                    have_to_write_simple_nonattr_statements["nodes"] or                    have_to_write_simple_nonattr_statements["edges"]                ):            statements += [""] # newline                    # Add simple nonattribute statements (nodes)        for statement in self.simple_statements["nonattribute"]["nodes"]:            statements += ["\t" + statement.assemble()]                if have_to_write_simple_nonattr_statements["nodes"] and have_to_write_simple_nonattr_statements["edges"]:            statements += [""] # newline                # Add simple nonattribute statements (edges)        for statement in self.simple_statements["nonattribute"]["edges"]:            statements += ["\t" + (statement.assemble() % self.edge_type)]                # Close statement        statements += ["}"]                # Return assembled statements        return {                "statement": "\n".join(statements),                 "lines": statements            }class GraphStatement(ComplexStatement):    """    This clas wraps a ComplexStatement whose keyword is    either graph or digraph    """        def __init__(self, keyword, *args, **kwargs):        """        Initialises the graph statement                Parameters:            - keyword: the keyword            *args: a series of SimpleStatement, Subgraph or Cluster instances to be embedded into                the graph statement (optional)            **kwargs: a series of named arguments defining the attribute list                 for graphs or digraphs (string). If you wish to provide an id for                the graph statement you have to pass it as a parameter named 'name'                 (to avoid conflict with the 'id' attribute allowed by Graphviz) (optional)        """                super().__init__(keyword, *args, **kwargs)                self.can_be_child = Falseclass Graph(GraphStatement):    """    This clas wraps a GraphStatement whose keyword is graph (undirected graph)    """        def __init__(self, *args, **kwargs):        """        Initialises the graph statement                Parameters:            *args: a series of SimpleStatement, Subgraph or Cluster instances to be embedded into                the graph statement (optional)            **kwargs: a series of named arguments defining the attribute list                 for graphs (string). If you wish to provide an id for                the graph statement you have to pass it as a parameter named 'name'                 (to avoid conflict with the 'id' attribute allowed by Graphviz) (optional)        """                super().__init__("graph", *args, **kwargs)                self.edge_type = "--"class Digraph(GraphStatement):    """    This clas wraps a GraphStatement whose keyword is digraph (directed graph)    """        def __init__(self, *args, **kwargs):        """        Initialises the digraph statement                Parameters:            *args: a series of SimpleStatement, Subgraph or Cluster instances to be embedded into                the digraph statement (optional)            **kwargs: a series of named arguments defining the attribute list                 for digraphs (string). If you wish to provide an id for                the digraph statement you have to pass it as a parameter named 'name'                 (to avoid conflict with the 'id' attribute allowed by Graphviz) (optional)        """                super().__init__("digraph", *args, **kwargs)                self.edge_type = "->"class Subgraph(ComplexStatement):    """    This clas wraps a ComplexStatement whose keyword is subgraph    """        def __init__(self, *args, **kwargs):        """        Initialises the subgraph statement                Parameters:            *args: a series of SimpleStatement, Subgraph or Cluster instances to be embedded into                the digraph statement (optional)            **kwargs: a series of named arguments defining the attribute list                 for digraphs (string). If you wish to provide an id for                the digraph statement you have to pass it as a parameter named 'name'                 (to avoid conflict with the 'id' attribute allowed by Graphviz) (optional)        """                super().__init__("subgraph", *args, **kwargs)class Cluster(Subgraph):    """    This clas wraps a ComplexStatement whose keyword is subgraph and which defines a cluster.    Notice that, in Graphviz, clusters are subgrapphs whose ID starts with 'cluster'    """        def __init__(self, *args, **kwargs):        """        Initialises the cluster statement                Parameters:            *args: a series of SimpleStatement, Subgraph or Cluster instances to be embedded into                the digraph statement (optional)            **kwargs: a series of named arguments defining the attribute list                 for digraphs (string). An ID must be provided by pasing it as a parameter                named 'name' (to avoid conflict with the 'id' attribute allowed by Graphviz) (optional)        """                super().__init__(*args, **kwargs)                if self.name is None:            raise Exception("Error in Cluster initialisation: a cluster must have an id! Provide one by passing the name parameter to the constructor.")                    self.name = "cluster_" + self.name